1、面向对象编程的特性:

> 抽象、封装和数据隐藏、多态、继承、代码的可重用性

2、过程性编程

> 首先要考虑遵循的步骤，然后考虑如何表示这些数据。并不需要程序一直运行，用户可能希望能够将数据存储在一个文件中，然后从这个文件中读取数据。面向对象编程，首先考虑数据，不仅考虑如何表示数据，还要考虑如何使用数据。

3、类是用户定义类型的定义，类规范由两个部分组成:

> 类声明：以数据成员的方式描述数据部分，以成员函数的方式描述共有接口
>
> 类方法定义:描述如何实现类成员函数。

4、内联函数:

> 其定义位于类声明中的函数自动成为内联函数，也可以在类声明外定义内联函数，但要加上关键字inline

5、类构造函数:

> 专门用于构造新对象，将值赋给它们的数据成员。构造函数没有返回值，构造函数的参数名不能与类成员的相同

6、析构函数:

> 完成清理操作，一般释放内存

7、this指针，当成员函数涉及到两个对象时，在这种情况下可能需要this指针，this指针指向指向调用对象，指向的是地址

8、类如何实现抽象、封装、和数据隐藏

> 抽象: 类表示人们可以使用类方法的共有接口对类对象执行的操作
>
> 数据隐藏: 类的数据成员是私有的，只能通过成员函数来访问这些数据
>
> 封装: 实现的具体细节都是隐藏的

9、默认构造函数是没有参数值或者所有参数值都有默认值的构造函数。拥有默认构造函数后，可以声明对象，而不初始化它。
10、运算符重载是一种形式的c++多态
11、友元函数:通过让函数成为类的友元，可以赋值该函数与类的成员函数相同的权限。友元函数看作类的扩展接口的组成部分，另外只有类声明决定哪一个函数是友元函数，因此类声明任然控制了哪些函数可以访问私有数据。没有违反数据隐藏的原则。
12、转换函数用于强制类型转换，必须是类方法，不能指定返回类型，不能有参数
13、复制构造函数：用于将一个对象复制到新创建的对象中
14、默认复制构造函数：将逐个赋值分静态成员，成员赋值也称为浅赋值。
15、如果类中包含这样的静态成员，即其值将在新对象被创建时发生变化，则应该提供一个显示复制构造函数来处理计数问题
16、显示复制构造函数:也叫深度复制
17、类继承:能够从已有的类派生出新的类，而派生类继承了原有类的特征，包括方法。派生类不能直接访问基类的私有成员，必须通过基类的方法进行访问
18、c++有三种继承方式:

- 公有继承:is-a关系
-  保护继承
- 私有继承
- 若继承方式是public，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；
- 若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限；
-   若继承方式是protected，基类的共有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。

19、多态公有继承:同一个方法在派生类和基类中的行为不同。方法的行为应却决于调用方法的对象。
    有两种方法可用于实现多态共有继承:

- 在派生类中重新定义基类的方法
- 使用虚方法。如果没有使用虚方法，程序将根据引用类型或指针类型选择方法，如果使用了虚方法，程序将根据引用或指针指向的对象的类型来选择方法

20、虚析构函数：确保释放派生对象时，按正确的顺序调用析构函数。
21、静态联编:在编译过程中进行联编
    动态联编:编译器必须生成能够在程序运行时选择正确的虚方法的代码
22、为什么不摒弃静态联编
    因为要考虑效率。并不是所有的派生类都重新定义基类的方法，也不需要动态联编，这种情况下静态联编更合理。
23、构造函数不能是虚函数，创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数。然后派生类的构造函数将使用基类的一个构造函数，这种顺序不同于继承机制。友元函数不能是虚函数，因为虚函数必须是成员函数，友元函数不是成员函数
24、抽象基类:类声明中包含纯虚函数。抽象基类将不能创建对象，只能用作基类
    纯虚函数:类声明时函数结尾处为"=0"
25、派生类从基类那里继承了什么?
    继承了公有成员、保护成员、私有成员，但是私有成员不能直接访问
26、派生类不能从基类继承什么?
    不能继承构造函数、析构函数、负值运算符和友元
27、如果派生类没有添加任何数据成员，它是否需要构造函数?
    需要，每个类必须有构造函数
28、在什么情况下，派生类需要定义赋值运算符?
    如果派生类构造函数使用new运算符来初始化类的指针成员，则应定义一个赋值运算符。更普遍的说，如果对于派生类成员来说，默认赋值不正确，则应定义赋值运算符。
29、为什么按引用传递对象比按值传递对象的效率高
    按引用传递对象，可以确保函数从虚函数收益，另外，按引用传递对象可以节省内存空间。按值传递
    对象的主要优点在于保护原始数据，但是可以将引用作为const类型传递，也可以达到同样的目的。
30、使用explict关闭隐式转换
31、关键字template<class Type>来定义一个模板
32、虚基类的概念:虚基类是为了防止多重继承时，当两条继承类有相同的祖先时，则类中将包含祖先成员的两个拷贝。

